// Generated by CoffeeScript 1.9.2
(function(root, factory) {
  if (('function' === typeof define) && (define.amd != null)) {
    return define(factory);
  } else if (typeof exports !== "undefined" && exports !== null) {
    return module.exports = factory();
  } else {
    return root.helfer = factory();
  }
})(this, function() {
  var helfer;
  helfer = {};
  helfer.camelToSnake = function(string) {
    return string.replace(/([a-z][A-Z])/g, function(m) {
      return m[0] + '_' + m[1].toLowerCase();
    });
  };
  helfer.snakeToCamel = function(string) {
    return string.replace(/_([a-z])/g, function(m) {
      return m[1].toUpperCase();
    });
  };
  helfer.camelToHyphen = function(string) {
    return string.replace(/([a-z][A-Z])/g, function(m) {
      return m[0] + '-' + m[1].toLowerCase();
    });
  };
  helfer.hyphenToCamel = function(string) {
    return string.replace(/-([a-z])/g, function(m) {
      return m[1].toUpperCase();
    });
  };
  helfer.colonToSnake = function(string) {
    return string.replace(/:/g, '_');
  };
  helfer.snakeToColon = function(string) {
    return string.replace(/_/g, ':');
  };
  helfer.hyphenColonToCamelSnake = function(string) {
    return helfer.hyphenToCamel(helfer.colonToSnake(string));
  };
  helfer.camelSnakeToHyphenColon = function(string) {
    return helfer.camelToHyphen(helfer.snakeToColon(string));
  };
  helfer.uppercaseFirstLetter = function(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  helfer.lowercaseFirstLetter = function(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
  };
  helfer.splitCamelcase = function(string) {
    return string.match(/([A-Z]?[^A-Z]*)/g).slice(0, -1).map(function(x) {
      return x.toLowerCase();
    });
  };
  helfer.joinCamelcase = function(array) {
    var capitalize;
    capitalize = function(string) {
      return helfer.uppercaseFirstLetter(string.toLowerCase());
    };
    return helfer.lowercaseFirstLetter(array.map(capitalize).join(''));
  };
  helfer.splitUnderscore = function(string) {
    if (string === '') {
      return [];
    }
    return string.split('_');
  };
  helfer.joinUnderscore = function(array) {
    return array.join('_');
  };
  helfer.splitUppercaseUnderscore = function(string) {
    if (string === '') {
      return [];
    }
    return string.split('_').map(function(x) {
      return x.toLowerCase();
    });
  };
  helfer.joinUppercaseUnderscore = function(array) {
    return array.map(function(x) {
      return x.toUpperCase();
    }).join('_');
  };
  helfer.coerceToArray = function(arg) {
    if (Array.isArray(arg)) {
      return arg;
    }
    if (arg == null) {
      return [];
    }
    return [arg];
  };
  helfer.findIndex = function(array, predicate) {
    var index, length;
    index = -1;
    length = array.length;
    while (++index < length) {
      if (predicate(array[index])) {
        return index;
      }
    }
    return -1;
  };
  helfer.findIndexWhereProperty = function(objects, property) {
    return helfer.findIndex(objects, function(object) {
      return helfer.isObject(object) && (!helfer.isUndefined(object[property]));
    });
  };
  helfer.findIndexWhereSequence = function(array, sequence) {
    var index, length, matchingSequenceIndex;
    if (sequence.length === 0) {
      return -1;
    }
    matchingSequenceIndex = -1;
    index = -1;
    length = array.length;
    while (++index < length) {
      if (matchingSequenceIndex !== -1) {
        matchingSequenceIndex++;
        if (matchingSequenceIndex === sequence.length) {
          return index - matchingSequenceIndex;
        }
        if (array[index] !== sequence[matchingSequenceIndex]) {
          matchingSequenceIndex = -1;
        }
      } else {
        if (array[index] === sequence[0]) {
          if (sequence.length === 1) {
            return index;
          }
          matchingSequenceIndex = 0;
        }
      }
    }
    if (matchingSequenceIndex !== -1 && matchingSequenceIndex + 1 === sequence.length) {
      return index - sequence.length;
    }
    return -1;
  };
  helfer.splitArrayWhere = function(array, predicate) {
    var index;
    index = helfer.findIndex(array, predicate);
    if (index === -1) {
      return [array, []];
    }
    return [array.slice(0, index), array.slice(index)];
  };
  helfer.splitArrayWhereSequence = function(array, value) {
    var index, rest, results, sequence;
    sequence = helfer.coerceToArray(value);
    results = [];
    rest = array;
    while (true) {
      index = helfer.findIndexWhereSequence(rest, sequence);
      if (index === -1) {
        results.push(rest);
        return results;
      } else {
        results.push(rest.slice(0, index));
        rest = rest.slice(index + sequence.length);
      }
    }
  };
  helfer.reverseIndex = function(index) {
    var reverseIndex;
    reverseIndex = {};
    Object.keys(index).forEach(function(key) {
      var value;
      value = index[key];
      if ('string' !== typeof value) {
        throw Error('all keys in index must map to a string');
      }
      if (reverseIndex[value] == null) {
        reverseIndex[value] = [];
      }
      return reverseIndex[value].push(key);
    });
    return reverseIndex;
  };
  helfer.inherits = function(constructor, superConstructor) {
    var proxyConstructor;
    if ('function' === typeof Object.create) {
      constructor.prototype = Object.create(superConstructor.prototype);
      return constructor.prototype.constructor = constructor;
    } else {
      proxyConstructor = function() {};
      proxyConstructor.prototype = superConstructor.prototype;
      constructor.prototype = new proxyConstructor;
      return constructor.prototype.constructor = constructor;
    }
  };
  helfer.parseFunctionArguments = function(fun) {
    var argumentPart, string;
    if ('function' !== typeof fun) {
      throw new Error('argument must be a function');
    }
    string = fun.toString();
    argumentPart = string.slice(string.indexOf('(') + 1, string.indexOf(')'));
    return argumentPart.match(/([^\s,]+)/g) || [];
  };
  helfer.identity = function(x) {
    return x;
  };
  helfer.isObject = function(x) {
    return x === Object(x);
  };
  helfer.isUndefined = function(x) {
    return 'undefined' === typeof x;
  };
  helfer.isNull = function(x) {
    return null === x;
  };
  helfer.isExisting = function(x) {
    return x != null;
  };
  helfer.isThenable = function(x) {
    return helfer.isObject(x) && 'function' === typeof x.then;
  };
  helfer.isError = function(x) {
    return x instanceof Error;
  };
  return helfer;
});
