// Generated by CoffeeScript 1.9.2
(function(root, factory) {
  if (('function' === typeof define) && (define.amd != null)) {
    return define(factory);
  } else if (typeof exports !== "undefined" && exports !== null) {
    return module.exports = factory();
  } else {
    return root.helfer = factory();
  }
})(this, function() {
  var helfer;
  helfer = {};
  helfer.camelToSnake = function(string) {
    return string.replace(/([a-z][A-Z])/g, function(m) {
      return m[0] + '_' + m[1].toLowerCase();
    });
  };
  helfer.snakeToCamel = function(string) {
    return string.replace(/_([a-z])/g, function(m) {
      return m[1].toUpperCase();
    });
  };
  helfer.camelToHyphen = function(string) {
    return string.replace(/([a-z][A-Z])/g, function(m) {
      return m[0] + '-' + m[1].toLowerCase();
    });
  };
  helfer.hyphenToCamel = function(string) {
    return string.replace(/-([a-z])/g, function(m) {
      return m[1].toUpperCase();
    });
  };
  helfer.colonToSnake = function(string) {
    return string.replace(/:/g, '_');
  };
  helfer.snakeToColon = function(string) {
    return string.replace(/_/g, ':');
  };
  helfer.hyphenColonToCamelSnake = function(string) {
    return helfer.hyphenToCamel(helfer.colonToSnake(string));
  };
  helfer.camelSnakeToHyphenColon = function(string) {
    return helfer.camelToHyphen(helfer.snakeToColon(string));
  };
  helfer.uppercaseFirstLetter = function(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  helfer.lowercaseFirstLetter = function(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
  };
  helfer.splitCamelcase = function(string) {
    return string.match(/([A-Z]?[^A-Z]*)/g).slice(0, -1).map(function(x) {
      return x.toLowerCase();
    });
  };
  helfer.joinCamelcase = function(array) {
    var capitalize;
    capitalize = function(string) {
      return helfer.uppercaseFirstLetter(string.toLowerCase());
    };
    return helfer.lowercaseFirstLetter(array.map(capitalize).join(''));
  };
  helfer.joinUnderscore = function(array) {
    return array.join('_');
  };
  helfer.coerceToArray = function(arg) {
    if (Array.isArray(arg)) {
      return arg;
    }
    if (arg == null) {
      return [];
    }
    return [arg];
  };
  helfer.findIndex = function(array, predicate) {
    var index, length;
    index = -1;
    length = array.length;
    while (++index < length) {
      if (predicate(array[index])) {
        return index;
      }
    }
    return -1;
  };
  helfer.findIndexOfFirstObjectHavingProperty = function(objects, property) {
    return helfer.findIndex(objects, function(object) {
      return helfer.isObject(object) && (!helfer.isUndefined(object[property]));
    });
  };
  helfer.splitArrayWhere = function(array, predicate) {
    var index;
    index = helfer.findIndex(array, predicate);
    if (index === -1) {
      return [array, []];
    }
    return [array.slice(0, index), array.slice(index)];
  };
  helfer.splitArrayWhereSequence = function(array, value) {
    var currentPartition, i, length, matchingSequence, partitions, splitSequence;
    splitSequence = helfer.coerceToArray(value);
    partitions = [];
    currentPartition = [];
    i = 0;
    length = array.length;
    matchingSequence = [];
    while (i < length) {
      if (array[i] === splitSequence[matchingSequence.length]) {
        matchingSequence.push(value[matchingSequence.length]);
        if (splitSequence.length === matchingSequence.length) {
          partitions.push(currentPartition);
          currentPartition = [];
          matchingSequence = [];
        }
      } else {
        if (matchingSequence.length !== 0) {
          currentPartition = currentPartition.concat(matchingSequence);
          matchingSequence = [];
        }
        currentPartition.push(array[i]);
      }
      i++;
    }
    if (matchingSequence.length !== 0) {
      currentPartition = currentPartition.concat(matchingSequence);
    }
    partitions.push(currentPartition);
    return partitions;
  };
  helfer.reverseIndex = function(index) {
    var reverseIndex;
    reverseIndex = {};
    Object.keys(index).forEach(function(key) {
      var value;
      value = index[key];
      if ('string' !== typeof value) {
        throw Error('all keys in index must map to a string');
      }
      if (reverseIndex[value] == null) {
        reverseIndex[value] = [];
      }
      return reverseIndex[value].push(key);
    });
    return reverseIndex;
  };
  helfer.inherits = function(constructor, superConstructor) {
    var proxyConstructor;
    if ('function' === typeof Object.create) {
      constructor.prototype = Object.create(superConstructor.prototype);
      return constructor.prototype.constructor = constructor;
    } else {
      proxyConstructor = function() {};
      proxyConstructor.prototype = superConstructor.prototype;
      constructor.prototype = new proxyConstructor;
      return constructor.prototype.constructor = constructor;
    }
  };
  helfer.parseFunctionArguments = function(fun) {
    var argumentPart, string;
    if ('function' !== typeof fun) {
      throw new Error('argument must be a function');
    }
    string = fun.toString();
    argumentPart = string.slice(string.indexOf('(') + 1, string.indexOf(')'));
    return argumentPart.match(/([^\s,]+)/g) || [];
  };
  helfer.identity = function(x) {
    return x;
  };
  helfer.isObject = function(x) {
    return x === Object(x);
  };
  helfer.isUndefined = function(x) {
    return 'undefined' === typeof x;
  };
  helfer.isNull = function(x) {
    return null === x;
  };
  helfer.isExisting = function(x) {
    return x != null;
  };
  helfer.isThenable = function(x) {
    return helfer.isObject(x) && 'function' === typeof x.then;
  };
  helfer.isError = function(x) {
    return x instanceof Error;
  };
  return helfer;
});
